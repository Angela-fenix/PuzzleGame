<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>æ‹¼åœ–éŠæˆ²</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        h1 {
            margin-bottom: 10px;
        }

        #timer {
            font-size: 1.5rem;
            margin-bottom: 10px;
            visibility: hidden;
        }

        #counter {
            font-size: 1.0rem;
            margin-bottom: 10px;
            visibility: hidden;
        }

        #puzzle {
            display: flex;
            flex-wrap: wrap;
            border: 2px solid #333;
            position: relative;
        }

        .tile {
            box-sizing: border-box;
            background-size: cover;
            border: 1px solid #999;
            cursor: grab;
        }

        .empty {
            background: #eee;
            border: 1px dashed #aaa;
        }

        button {
            margin-top: 10px;
            padding: 8px 16px;
            margin-right: 5px;
        }

        select,
        input[type="file"] {
            padding: 5px 10px;
            margin-right: 5px;
        }

        .controls {
            margin-top: 10px;
        }

        /* æ¨™ç¤ºå‡ºå–®è‰²å¡Š
        .tile[ignore="true"] {
            outline: 3px dashed orange;
        } */
    </style>
</head>

<body>

    <div id="overlay">3</div>

    <h1>æ‹¼åœ–éŠæˆ²</h1>
    <div id="timer">æ™‚é–“ï¼š0 ç§’</div>
    <div id="counter">ç§»å‹•æ¬¡æ•¸ï¼š0 æ¬¡</div>
    <div id="puzzle"></div>

    <div class="controls">
        <label>
            æ‹¼åœ–å¤§å°ï¼š
            <select id="sizeSelect" onchange="changeSize()">
                <option value="3">3x3</option>
                <option value="4">4x4</option>
                <option value="5">5x5</option>
            </select>
        </label>

        <label>
            ä¸Šå‚³åœ–ç‰‡ï¼š
            <input type="file" accept="image/*" onchange="uploadImage(event)">
        </label>

        <button onclick="restart()">é‡æ–°é–‹å§‹</button>
    </div>

    <script>
        const puzzle = document.getElementById('puzzle');
        const overlay = document.getElementById('overlay');
        const timerDisplay = document.getElementById('timer');
        const counterDisplay = document.getElementById('counter');
        const sizeSelect = document.getElementById('sizeSelect');

        let size = parseInt(sizeSelect.value);
        let imageUrl = './vito_by_egg.png'; // é è¨­åœ–ç‰‡
        let tiles = [];
        let tileSize = 100; // æœƒæ ¹æ“š size å‹•æ…‹èª¿æ•´
        let timer = null;
        let seconds = 0;
        let steps = 0;
        let gameActive = true;

        function createTiles() {
            puzzle.innerHTML = '';
            tiles = [];

            tileSize = 100 * (3 / size); // è‡ªå‹•èª¿æ•´ tile å°ºå¯¸
            puzzle.style.width = `${tileSize * size}px`;
            puzzle.style.height = `${tileSize * size}px`;

            // å»ºç«‹ä¸€å€‹éš±è—çš„ canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            // img.crossOrigin = 'anonymous'; // é¿å…è·¨åŸŸå•é¡Œï¼Œåœ–ç‰‡å­˜åœ¨æœ¬åœ°ç«¯æ™‚ä¸éœ€è¦æ­¤è¡Œ
            img.src = imageUrl;

            img.onload = () => {

                // Canvas ç¸®æ”¾åˆ°èˆ‡æ‹¼åœ–é¡¯ç¤ºç›¸åŒ
                canvas.width = tileSize * size;
                canvas.height = tileSize * size;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const tile = document.createElement('div');
                        tile.classList.add('tile');
                        tile.style.width = `${tileSize}px`;
                        tile.style.height = `${tileSize}px`;
                        tile.style.backgroundImage = `url('${imageUrl}')`;
                        tile.style.backgroundSize = `${tileSize * size}px ${tileSize * size}px`;
                        tile.style.backgroundPosition = `-${x * tileSize}px -${y * tileSize}px`;
                        tile.dataset.index = y * size + x;
                        tile.draggable = true;

                        // åˆ¤æ–·æ˜¯å¦ç‚ºå–®è‰²
                        const imgX = x * tileSize;
                        const imgY = y * tileSize;
                        const imgW = tileSize;
                        const imgH = tileSize;

                        const isMono = isTileMonochrome(ctx, imgX, imgY, imgW, imgH);
                        console.log('[' + x + ',' + y + ']: ' + isMono);

                        tile.dataset.ignore = isMono ? "true" : "false";
                        if (isMono) {
                            tile.setAttribute('ignore', 'true'); // CSS æ¨£å¼æç¤º
                        }

                        tiles.push(tile);
                    }
                }

                // æœ€å¾Œä¸€å¡Šæ˜¯ç©ºç™½
                const last = tiles[tiles.length - 1];
                last.classList.add('empty');
                last.style.backgroundImage = 'none';

                tiles.forEach(tile => puzzle.appendChild(tile));
                // addDragEvents();
                enableClickMove(); // é–‹å•Ÿé»æ“Šäº’å‹•
            };
        }

        function isTileMonochrome(ctx, x, y, w, h) {
            const imgData = ctx.getImageData(x, y, w, h).data;
            const threshold = 10; // èª¤å·®å®¹å¿å€¼     

            let allBlack = true;
            let allWhite = true;

            for (let i = 0; i < imgData.length; i += 4) {
                const r = imgData[i];
                const g = imgData[i + 1];
                const b = imgData[i + 2];
                const a = imgData[i + 3];

                // å¿½ç•¥é€æ˜åƒç´   
                if (a < 50) { continue; }

                // åˆ¤æ–·ä¸æ˜¯é»‘
                if (r > threshold || g > threshold || b > threshold) {
                    allBlack = false;
                }

                // åˆ¤æ–·ä¸æ˜¯ç™½
                if (r < (255 - threshold) || g < (255 - threshold) || b < (255 - threshold)) {
                    allWhite = false;
                }

                if (!allBlack && !allWhite) break;
            }

            return allBlack || allWhite;
        }

        //æ‹–ç§»æ–¹å¼ç§»å‹•æ‹¼åœ–
        /*function addDragEvents() {
            tiles.forEach(tile => {
                const newTile = tile.cloneNode(true); // ç§»é™¤æ‰€æœ‰èˆŠäº‹ä»¶
                puzzle.replaceChild(newTile, tile);
            });

            tiles = Array.from(puzzle.children);

            let dragged;

            tiles.forEach(tile => {
                tile.addEventListener('dragstart', () => {
                    if (!gameActive) return e.preventDefault(); // ç¦æ­¢æ‹–å‹•
                    dragged = tile;
                });

                tile.addEventListener('dragover', (e) => {
                    if (!gameActive) return;
                    e.preventDefault();
                });

                tile.addEventListener('drop', () => {
                    if (!gameActive) return;

                    if (dragged && dragged !== tile && tile.classList.contains('empty')) {
                        swapTiles(dragged, tile);
                        startCounter();

                        if (isSolved()) {
                            clearInterval(timer);
                            gameActive = false; //åœæ­¢æ‹–å‹•
                            alert(`å®Œæˆæ‹¼åœ–ï¼ğŸ‰\nç”¨æ™‚ï¼š${seconds} ç§’`);
                        }
                    }
                });
            });
        }*/

        //é»æ“Šç§»å‹•æ–¹å¼
        function enableClickMove() {
            tiles.forEach(tile => {
                tile.onclick = () => {
                    if (!gameActive) return;
                    if (tile.classList.contains('empty')) return;

                    const tileIndex = tiles.indexOf(tile);
                    const emptyIndex = tiles.findIndex(t => t.classList.contains('empty'));

                    if (isAdjacent(tileIndex, emptyIndex)) {
                        swapTiles(tile, tiles[emptyIndex]);
                        startCounter();

                        if (isSolved()) finishPuzzle();
                    }
                };

                // æ‹–æ›³æ”¯æ´
                tile.addEventListener('dragstart', (e) => {
                    if (!gameActive) return e.preventDefault();  // ç¦æ­¢æ‹–å‹•
                    tile.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', tiles.indexOf(tile));
                });

                tile.addEventListener('dragover', (e) => {
                    if (!gameActive) return;
                    e.preventDefault();
                });

                tile.addEventListener('drop', (e) => {
                    if (!gameActive) return;
                    e.preventDefault();

                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = tiles.indexOf(tile);
                    const fromTile = tiles[fromIndex];

                    if (tile.classList.contains('empty')) {
                        swapTiles(fromTile, tile);
                        startCounter();

                        if (isSolved()) finishPuzzle();
                    }
                });

                // æ¨¡æ“¬è§¸æ§æ‹–æ›³ for iOS
                let startX, startY;
                tile.addEventListener('touchstart', (e) => {
                    if (!gameActive || tile.classList.contains('empty')) return;
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                });

                tile.addEventListener('touchend', (e) => {
                    if (!gameActive || tile.classList.contains('empty')) return;
                    const emptyTile = tiles.find(t => t.classList.contains('empty'));
                    const rect = emptyTile.getBoundingClientRect();
                    const dx = Math.abs(startX - rect.left - tileSize / 2);
                    const dy = Math.abs(startY - rect.top - tileSize / 2);

                    if ((dx < tileSize && dy === 0) || (dy < tileSize && dx === 0)) {
                        swapTiles(tile, emptyTile);
                        startCounter();
                        if (isSolved()) finishPuzzle();
                    }
                });
            });
        }

        function isAdjacent(i1, i2) {
            const x1 = i1 % size, y1 = Math.floor(i1 / size);
            const x2 = i2 % size, y2 = Math.floor(i2 / size);
            return (Math.abs(x1 - x2) + Math.abs(y1 - y2)) === 1;
        }

        function finishPuzzle() {
            clearInterval(timer);
            gameActive = false;
            alert(`å®Œæˆæ‹¼åœ–ï¼ğŸ‰\nç”¨æ™‚ï¼š${seconds} ç§’\nç§»å‹•ï¼š${steps} æ¬¡`);
        }

        //äº¤æ› DOM é †åºå’Œ tiles é™£åˆ—
        function swapTiles(a, b) {
            const aIndex = tiles.indexOf(a);
            const bIndex = tiles.indexOf(b);

            // äº¤æ› tiles é™£åˆ—ä¸­çš„ä½ç½®
            const temp = tiles[aIndex];
            tiles[aIndex] = tiles[bIndex];
            tiles[bIndex] = temp;

            // é‡æ–°æ ¹æ“š tiles é™£åˆ—é †åºåˆ·æ–° DOM
            tiles.forEach(tile => puzzle.appendChild(tile));
        }

        function shuffle() {  //æ‰“äº‚æ‹¼åœ–
            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                puzzle.insertBefore(tiles[j], tiles[i]);
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
            }

            tiles = Array.from(puzzle.children); //åŒæ­¥ tiles é™£åˆ—èˆ‡ç•«é¢é †åº

            // addDragEvents();
            enableClickMove(); //æ‰“äº‚å¾Œé‡æ–°ç¶å®šé»æ“Šèˆ‡æ‹–æ›³
        }

        function isSolved() {  //æª¢æŸ¥æ‹¼åœ–æ˜¯å¦å®Œæˆ
            const domTiles = Array.from(puzzle.children);

            return domTiles.every((tile, index) => {
                if (tile.dataset.ignore === "true") {
                    return true; // å–®è‰²å¡Šå¿½ç•¥
                }
                return tile.dataset.index == index;
            });
        }

        function startTimer() {  //è¨ˆæ™‚å™¨
            seconds = 0;
            timerDisplay.textContent = `æ™‚é–“ï¼š${seconds} ç§’`;
            timerDisplay.style.visibility = 'visible';

            timer = setInterval(() => {
                seconds++;
                timerDisplay.textContent = `æ™‚é–“ï¼š${seconds} ç§’`;
            }, 1000);
        }

        function startCounter() {  //è¨ˆæ•¸å™¨
            if (!gameActive) return;

            steps++;
            counterDisplay.textContent = `ç§»å‹•æ¬¡æ•¸ï¼š${steps} æ¬¡`;
        }

        function countdown(start = 3) {  //å€’æ•¸ç•«é¢
            let count = start;
            overlay.textContent = count;
            overlay.style.display = 'flex';

            steps = 0;
            counterDisplay.textContent = `ç§»å‹•æ¬¡æ•¸ï¼š${steps} æ¬¡`;
            counterDisplay.style.visibility = 'visible';

            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    overlay.textContent = count;
                } else {
                    clearInterval(interval);
                    overlay.style.display = 'none';
                    shuffle();
                    startTimer();
                }
            }, 1000);
        }

        function restart() {
            clearInterval(timer);
            gameActive = true;  // é–‹å•Ÿæ‹–å‹•

            createTiles();
            overlay.style.display = 'flex';
            countdown();
        }

        function changeSize() {
            size = parseInt(sizeSelect.value);
            restart();
        }

        function uploadImage(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    imageUrl = e.target.result;
                    restart();
                };
                reader.readAsDataURL(file);
            }
        }

        // åˆå§‹åŒ–
        createTiles();
        countdown();
    </script>

</body>

</html>