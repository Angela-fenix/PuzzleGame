<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>æ‹¼åœ–éŠæˆ²</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        #birthdayText {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            display: none;
            padding: 20px 40px;
            border-radius: 12px;
            background-color: rgba(240, 240, 240, 0.705);
            /* æ·ºç°åº• */
            text-align: center;
            animation: fadeInScale 1s ease-out forwards;
        }

        #birthdayText span {
            /* æ¡ƒç´…æ¼¸å±¤æ–‡å­—*/
            font-size: clamp(2rem, 6vw, 5rem);
            font-weight: bold;
            background: linear-gradient(90deg, #e98be9, #ec6fd1, #f7e48f, #6cc3e6);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: inline-block;
            animation: rainbowText 6s linear infinite;
        }

        @keyframes fadeInScale {
            0% {
                transform: translateX(-50%) scale(0.5);
                opacity: 0;
            }

            100% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes rainbowText {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .balloon {
            position: fixed;
            width: 40px;
            height: 60px;
            background-color: var(--color);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            z-index: 999;
            animation: floatUp 6s linear forwards;
            transform: rotate(var(--angle));
        }

        .string {
            position: absolute;
            left: 50%;
            top: 100%;
            width: 20px;
            height: 60px;
            transform: translateX(-50%);
            background: transparent;
        }

        .string::before {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle, #444 1px, transparent 1px);
            background-size: 4px 8px;
            background-repeat: repeat-y;
            left: 0;
            top: 0;
            mask-image: radial-gradient(circle, black 1px, transparent 1px);
        }

        @keyframes floatUp {
            0% {
                transform: translateY(100vh) scale(1) rotate(var(--angle));
                opacity: 1;
            }

            100% {
                transform: translateY(-150vh) scale(1.2) rotate(var(--angle));
                opacity: 0;
            }
        }

        h1 {
            margin-bottom: 10px;
        }

        #timer {
            font-size: 1.5rem;
            margin-bottom: 10px;
            visibility: hidden;
        }

        #counter {
            font-size: 1.0rem;
            margin-bottom: 10px;
            visibility: hidden;
        }

        #puzzle {
            display: flex;
            flex-wrap: wrap;
            border: 2px solid #333;
            position: relative;
        }

        .tile {
            box-sizing: border-box;
            background-size: cover;
            border: 1px solid #999;
            cursor: grab;
        }

        .empty {
            background: #eee;
            border: 1px dashed #aaa;
        }

        button {
            margin-top: 10px;
            padding: 8px 16px;
            margin-right: 5px;
        }

        select,
        input[type="file"] {
            padding: 5px 10px;
            margin-right: 5px;
        }

        .controls {
            margin-top: 10px;
        }

        /* æ¨™ç¤ºå‡ºå–®è‰²å¡Š
        .tile[ignore="true"] {
            outline: 3px dashed orange;
        }*/
    </style>
</head>

<body>
    <div id="overlay">3</div>
    <canvas id="celebration"></canvas>
    <div id="birthdayText">
        <span>æµ¦æ´‹ç”Ÿæ—¥å¿«æ¨‚ï¼</span>
    </div>

    <h1>æ‹¼åœ–éŠæˆ²</h1>
    <div id="timer">æ™‚é–“ï¼š0 ç§’</div>
    <div id="counter">ç§»å‹•æ¬¡æ•¸ï¼š0 æ¬¡</div>
    <div id="puzzle"></div>

    <div class="controls">
        <label>
            æ‹¼åœ–å¤§å°ï¼š
            <select id="sizeSelect" onchange="changeSize()">
                <option value="3">3x3</option>
                <option value="4">4x4</option>
                <option value="5">5x5</option>
            </select>
        </label>

        <!-- <label>
            ä¸Šå‚³åœ–ç‰‡ï¼š
            <input type="file" accept="image/*" onchange="uploadImage(event)">
        </label> -->

        <button onclick="restart()">é‡æ–°é–‹å§‹</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script>
        const celebrationCanvas = document.getElementById('celebration');
        const confettiInstance = confetti.create(celebrationCanvas, { resize: true, useWorker: true });

        function launchCelebration() {
            if (!window.hasStartedOnce) return; //é¦–æ¬¡é–‹å•Ÿç¶²é ä¸æ’­æ”¾å‹•ç•«

            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    confettiInstance({
                        particleCount: 100,
                        spread: 70,
                        origin: { y: 0.6 }
                    });
                }, i * 300);
            }

            // å‹•æ…‹ç”¢ç”Ÿæ°£çƒ
            for (let i = 0; i < 20; i++) {
                const balloon = document.createElement('div');
                balloon.className = 'balloon';

                const angle = `${Math.random() * 30 - 15}deg`;
                const left = Math.random() * 100;
                const top = Math.random() * 100;
                balloon.style.left = `${left}vw`;
                balloon.style.top = `${top}vw`;
                balloon.style.setProperty('--color', `hsl(${Math.random() * 360}, 100%, 70%)`);
                balloon.style.setProperty('--angle', angle);

                // const string = document.createElement('div');
                // string.className = 'string';
                // balloon.appendChild(string);
                // å»ºç«‹ç¹©å­æ›²ç·š
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                svg.setAttribute("width", "20");
                svg.setAttribute("height", "60");
                svg.setAttribute("viewBox", "0 0 20 60");
                svg.style.position = "absolute";
                svg.style.left = "50%";
                svg.style.top = "100%";
                svg.style.transform = "translateX(-50%)";

                const path = document.createElementNS(svgNS, "path");
                path.setAttribute("d", "M10,0 Q5,10 10,20 Q15,30 10,40 Q5,50 10,60"); // æ›²ç·šç¹©
                path.setAttribute("stroke", "#444");
                path.setAttribute("fill", "none");
                path.setAttribute("stroke-width", "1");

                svg.appendChild(path);
                balloon.appendChild(svg);

                document.body.appendChild(balloon);
                setTimeout(() => balloon.remove(), 6000);
            }


        }
    </script>

    <script>
        const puzzle = document.getElementById('puzzle');
        const overlay = document.getElementById('overlay');
        const timerDisplay = document.getElementById('timer');
        const counterDisplay = document.getElementById('counter');
        const sizeSelect = document.getElementById('sizeSelect');
        const birthdayText = document.getElementById('birthdayText');

        let size = parseInt(sizeSelect.value);
        let imageUrl = './vito_by_egg_white.png'; // é è¨­åœ–ç‰‡
        let tiles = [];
        let tileSize = 100; // æœƒæ ¹æ“š size å‹•æ…‹èª¿æ•´
        let timer = null;
        let seconds = 0;
        let steps = 0;
        let gameActive = true;
        window.hasStartedOnce = false;

        function createTiles() {
            puzzle.innerHTML = '';
            tiles = [];
            tileSize = 100 * (3 / size); // è‡ªå‹•èª¿æ•´ tile å°ºå¯¸
            puzzle.style.width = `${tileSize * size}px`;
            puzzle.style.height = `${tileSize * size}px`;

            // å»ºç«‹ä¸€å€‹éš±è—çš„ canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            // img.crossOrigin = 'anonymous'; // é¿å…è·¨åŸŸå•é¡Œï¼Œåœ–ç‰‡å­˜åœ¨æœ¬åœ°ç«¯æ™‚ä¸éœ€è¦æ­¤è¡Œ
            img.src = imageUrl;

            img.onload = () => {

                // Canvas ç¸®æ”¾åˆ°èˆ‡æ‹¼åœ–é¡¯ç¤ºç›¸åŒ
                canvas.width = tileSize * size;
                canvas.height = tileSize * size;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const tile = document.createElement('div');
                        tile.classList.add('tile');
                        tile.style.width = `${tileSize}px`;
                        tile.style.height = `${tileSize}px`;
                        tile.style.backgroundImage = `url('${imageUrl}')`;
                        tile.style.backgroundSize = `${tileSize * size}px ${tileSize * size}px`;
                        tile.style.backgroundPosition = `-${x * tileSize}px -${y * tileSize}px`;
                        tile.dataset.index = y * size + x;
                        tile.draggable = true;

                        // åˆ¤æ–·æ˜¯å¦ç‚ºå–®è‰²
                        const imgX = x * tileSize;
                        const imgY = y * tileSize;
                        const imgW = tileSize;
                        const imgH = tileSize;

                        const isMono = isTileMonochrome(ctx, imgX, imgY, imgW, imgH);
                        console.log('[' + x + ',' + y + ']: ' + isMono);

                        tile.dataset.ignore = isMono ? "true" : "false";
                        if (isMono) {
                            tile.setAttribute('ignore', 'true'); // CSS æ¨£å¼æç¤º
                        }

                        tiles.push(tile);
                    }
                }

                // æœ€å¾Œä¸€å¡Šæ˜¯ç©ºç™½
                const last = tiles[tiles.length - 1];
                last.classList.add('empty');
                last.style.backgroundImage = 'none';

                tiles.forEach(tile => puzzle.appendChild(tile));
                // addDragEvents();
                enableClickMove(); // é–‹å•Ÿé»æ“Šäº’å‹•
            };
        }

        //æª¢æŸ¥åƒç´ è®Šç•°åº¦
        //åˆ†ææ¯å¡Šæ‹¼åœ–æ˜¯å¦ç‚ºã€Œå…¨é»‘ã€æˆ–ã€Œå…¨ç™½ã€ï¼Œè‹¥åº•è‰²ç‚ºé€æ˜ï¼Œæœƒå½±éŸ¿åˆ¤æ–·
        function isTileMonochrome(ctx, x, y, w, h) {
            const imgData = ctx.getImageData(x, y, w, h).data;
            let totalPixels = imgData.length / 4;
            let rTotal = 0, gTotal = 0, bTotal = 0;

            for (let i = 0; i < imgData.length; i += 4) {
                rTotal += imgData[i];
                gTotal += imgData[i + 1];
                bTotal += imgData[i + 2];
            }

            const rAvg = rTotal / totalPixels;
            const gAvg = gTotal / totalPixels;
            const bAvg = bTotal / totalPixels;

            let variance = 0;
            for (let i = 0; i < imgData.length; i += 4) {
                const dr = imgData[i] - rAvg;
                const dg = imgData[i + 1] - gAvg;
                const db = imgData[i + 2] - bAvg;
                variance += dr * dr + dg * dg + db * db;
            }

            const stdDev = Math.sqrt(variance / totalPixels);  //æ¨™æº–å·®æª¢æŸ¥ï¼Œè¶Šå°è¶Šåƒå–®è‰²
            console.log("stdDev: " + stdDev);

            const isDark = rAvg < 15 && gAvg < 15 && bAvg < 15;
            const isBright = rAvg > 240 && gAvg > 240 && bAvg > 240;

            return stdDev < 2.5 && (isDark || isBright);
        }

        //é»æ“Š &æ‹–ç§»æ–¹å¼ç§»å‹•æ‹¼åœ–
        function enableClickMove() {
            tiles.forEach(tile => {
                tile.onclick = () => {
                    if (!gameActive) return;
                    if (tile.classList.contains('empty')) return;

                    const tileIndex = tiles.indexOf(tile);
                    const emptyIndex = tiles.findIndex(t => t.classList.contains('empty'));

                    if (isAdjacent(tileIndex, emptyIndex)) {
                        swapTiles(tile, tiles[emptyIndex]);
                        startCounter();

                        if (isSolved()) finishPuzzle();
                    }
                };

                // æ‹–æ›³æ”¯æ´
                tile.addEventListener('dragstart', (e) => {
                    if (!gameActive) return e.preventDefault();  // ç¦æ­¢æ‹–å‹•
                    tile.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', tiles.indexOf(tile));
                });

                tile.addEventListener('dragover', (e) => {
                    if (!gameActive) return;
                    e.preventDefault();
                });

                tile.addEventListener('drop', (e) => {
                    if (!gameActive) return;
                    e.preventDefault();

                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = tiles.indexOf(tile);
                    const fromTile = tiles[fromIndex];

                    if (tile.classList.contains('empty')) {
                        swapTiles(fromTile, tile);
                        startCounter();

                        if (isSolved()) finishPuzzle();
                    }
                });

                // æ¨¡æ“¬è§¸æ§æ‹–æ›³ for iOS
                let startX, startY;
                tile.addEventListener('touchstart', (e) => {
                    if (!gameActive || tile.classList.contains('empty')) return;
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                });

                tile.addEventListener('touchend', (e) => {
                    if (!gameActive || tile.classList.contains('empty')) return;
                    const emptyTile = tiles.find(t => t.classList.contains('empty'));
                    const rect = emptyTile.getBoundingClientRect();
                    const dx = Math.abs(startX - rect.left - tileSize / 2);
                    const dy = Math.abs(startY - rect.top - tileSize / 2);

                    if ((dx < tileSize && dy === 0) || (dy < tileSize && dx === 0)) {
                        swapTiles(tile, emptyTile);
                        startCounter();
                        if (isSolved()) finishPuzzle();
                    }
                });
            });
        }

        function isAdjacent(i1, i2) {
            const x1 = i1 % size, y1 = Math.floor(i1 / size);
            const x2 = i2 % size, y2 = Math.floor(i2 / size);
            return (Math.abs(x1 - x2) + Math.abs(y1 - y2)) === 1;
        }

        function finishPuzzle() {
            clearInterval(timer);
            gameActive = false;
            launchCelebration();    //å‘¼å«ç…™ç« + æ°£çƒ
            birthdayText.style.display = 'block';   //é¡¯ç¤ºæ–‡å­—

            // å»¶é² 2 ç§’å¾Œé¡¯ç¤º alert
            setTimeout(() => {
                alert(`å®Œæˆæ‹¼åœ–ï¼ğŸ‰\nç”¨æ™‚ï¼š${seconds} ç§’\nç§»å‹•ï¼š${steps} æ¬¡`);
                birthdayText.style.display = 'none';  //éš±è—æ–‡å­—
            }, 2000);
        }

        //äº¤æ› DOM é †åºå’Œ tiles é™£åˆ—
        function swapTiles(a, b) {
            const aIndex = tiles.indexOf(a);
            const bIndex = tiles.indexOf(b);

            // äº¤æ› tiles é™£åˆ—ä¸­çš„ä½ç½®
            const temp = tiles[aIndex];
            tiles[aIndex] = tiles[bIndex];
            tiles[bIndex] = temp;

            // é‡æ–°æ ¹æ“š tiles é™£åˆ—é †åºåˆ·æ–° DOM
            tiles.forEach(tile => puzzle.appendChild(tile));
        }

        function shuffle() {  //æ‰“äº‚æ‹¼åœ–
            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                puzzle.insertBefore(tiles[j], tiles[i]);
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
            }

            tiles = Array.from(puzzle.children); //åŒæ­¥ tiles é™£åˆ—èˆ‡ç•«é¢é †åº

            // addDragEvents();
            enableClickMove(); //æ‰“äº‚å¾Œé‡æ–°ç¶å®šé»æ“Šèˆ‡æ‹–æ›³
        }

        function isSolved() {  //æª¢æŸ¥æ‹¼åœ–æ˜¯å¦å®Œæˆ
            const domTiles = Array.from(puzzle.children);

            return domTiles.every((tile, index) => {
                if (tile.dataset.ignore === "true") {
                    return true; // å–®è‰²å¡Šå¿½ç•¥
                }
                return tile.dataset.index == index;
            });
        }

        function startTimer() {  //è¨ˆæ™‚å™¨
            seconds = 0;
            timerDisplay.textContent = `æ™‚é–“ï¼š${seconds} ç§’`;
            timerDisplay.style.visibility = 'visible';

            timer = setInterval(() => {
                seconds++;
                timerDisplay.textContent = `æ™‚é–“ï¼š${seconds} ç§’`;
            }, 1000);
        }

        function startCounter() {  //è¨ˆæ•¸å™¨
            if (!gameActive) return;

            steps++;
            counterDisplay.textContent = `ç§»å‹•æ¬¡æ•¸ï¼š${steps} æ¬¡`;
        }

        function countdown(start = 3) {  //å€’æ•¸ç•«é¢
            let count = start;
            overlay.textContent = count;
            overlay.style.display = 'flex';

            steps = 0;
            counterDisplay.textContent = `ç§»å‹•æ¬¡æ•¸ï¼š${steps} æ¬¡`;
            counterDisplay.style.visibility = 'visible';

            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    overlay.textContent = count;
                } else {
                    clearInterval(interval);
                    overlay.style.display = 'none';
                    window.hasStartedOnce = true; //å®Œæˆé¦–æ¬¡å•Ÿå‹•
                    shuffle();
                    startTimer();
                }
            }, 1000);
        }

        function restart() {
            clearInterval(timer);
            gameActive = true;  // é–‹å•Ÿæ‹–å‹•

            createTiles();
            overlay.style.display = 'flex';
            countdown();
        }

        function changeSize() {
            size = parseInt(sizeSelect.value);
            restart();
        }

        function uploadImage(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    imageUrl = e.target.result;
                    restart();
                };
                reader.readAsDataURL(file);
            }
        }

        // åˆå§‹åŒ–
        createTiles();
        countdown();
    </script>




</body>

</html>